# Личный подробный конспект по РР (Вариант 6)
## OSTIS / sc-machine: что сделано, как устроено, как объяснять и как проверять


---

## Содержание
1. Краткая идея варианта 6  
2. Как устроена OSTIS-система в контексте РР  
3. Представление сети в базе знаний (SCs)  
4. Action и запуск агента  
5. Внутреннее представление графа в агенте  
6. Точки сочленения и мосты (Tarjan)  
7. Рёберная связность λ (max-flow / min-cut)  
8. Вершинная связность κ (node-splitting + max-flow)  
9. Формирование результата в sc-памяти  
10. Unit-тесты: что проверяют и почему это доказательство  
11. Разбор тестов (Cycle, Chain, Star, Bowtie)  
12. Команды сборки/запуска: идеальный сценарий сдачи  
13. Интерпретация логов агента  
14. Типовые проблемы и решения  
15. Подготовка к защите: ответы на вопросы  
16. Приложения (структура проекта, полезные фрагменты)

---

## 1) Идея варианта 6 (самое главное)

Мы рассматриваем компьютерную сеть как **граф**:

- **Вершины** — устройства сети (ПК, серверы, коммутаторы, маршрутизаторы и т.п.).  
- **Рёбра** — физические соединения (кабели/каналы).  

Вариант 6 требует вычислить характеристики отказоустойчивости:

- **Вершинная связность κ**: минимальное число устройств, отказ которых разрывает сеть.  
- **Рёберная связность λ**: минимальное число линий связи, отказ которых разрывает сеть.  
- **Точки сочленения**: критические устройства.  
- **Мосты**: критические соединения.

Отдельное требование: граф **неориентированный** (связь двусторонняя).

---

## 2) OSTIS / sc-machine простыми словами (но строго)

### 2.1. sc-memory
`sc-memory` — это графовая база знаний (семантическая память). В ней есть:
- **узлы** (объекты/понятия/экземпляры),
- **коннекторы** (дуги/рёбра разных типов),
- **ссылки** (links) — например, для текста или чисел.

### 2.2. sc-machine
`sc-machine` — процесс, который хранит sc-memory и выполняет расширения (extensions), включая агентов.

### 2.3. SCs
SCs — текстовый язык описания знаний (как “исходники” для базы знаний), из которых сборщик (`sc-builder`) создаёт сегменты памяти.

### 2.4. sc-web
`sc-web` — веб-интерфейс для работы с базой знаний и запуска команд. Он полезен для демонстрации, но для доказательства корректности важнее тесты.

---

## 3) Как сеть задаётся в SCs

### 3.1. Устройства как вершины
Каждое устройство — узел, который можно типизировать (workstation, switch, router и т.д.). Это важно для пункта «граф с типами устройств».

### 3.2. Физические соединения как рёбра
Связи задаются отношением `nrel_physical_connection`. Логика простая:
- если есть физическое соединение между двумя устройствами, в графе есть ребро.

### 3.3. Почему мы обязаны делать граф неориентированным
Физический кабель не «односторонний». Даже если в памяти используется дуга, агент обязан интерпретировать её как двустороннюю связь.

---

## 4) Action и запуск агента (важно для понимания)

### 4.1. Что такое action
Action — объект “выполни задачу”. Он содержит:
- класс действия (что нужно сделать),
- аргументы (над чем сделать),
- состояние выполнения (успешно/ошибка).

### 4.2. Как агент активируется
Агент подписан на событие, возникающее при инициации action. Затем он проверяет:
- совпадает ли класс action,
- есть ли обязательный аргумент (топология).

Если не совпадает — корректно завершает обработку.

---

## 5) Внутренний граф в агенте (структуры данных)

Используется структура:
- `vertices`: список ScAddr устройств,
- `edges`: список рёбер `{u, v, arcAddr}`,
- `adj`: список смежности `adj[u] = [(to, edgeId), ...]`.

`arcAddr` нужен, чтобы потом в результате указывать мосты именно как те соединения, которые есть в KB.

---

## 6) Точки сочленения и мосты (Tarjan) — подробное объяснение

### 6.1. Определения
- **Мост** — ребро, удаление которого увеличивает число компонент связности.  
- **Точка сочленения** — вершина, удаление которой увеличивает число компонент связности.

### 6.2. Идея алгоритма
DFS строит дерево обхода. Для каждой вершины считаются:
- `tin[v]` — время входа,
- `low[v]` — минимальное `tin`, достижимое из v по дереву + одному обратному ребру.

Условия:
- `low[to] > tin[v]` ⇒ `(v,to)` — мост  
- `low[to] >= tin[v]` и v не корень ⇒ v — точка сочленения  
- корень — точка сочленения, если детей DFS больше 1

---

## 7) Рёберная связность λ (max-flow / min-cut) — подробный разбор

### 7.1. Почему поток
По теореме max-flow/min-cut, maxflow(s,t) равен ёмкости минимального разреза между s и t.

### 7.2. Как моделируем рёбра
Для каждого неориентированного ребра u—v добавляем две дуги:
- u→v (capacity=1)
- v→u (capacity=1)

Тогда минимальный разрез по рёбрам соответствует числу соединений, которые нужно удалить.

### 7.3. Почему берём минимум по всем парам
Потому что рёберная связность — глобальная характеристика: берётся наихудший случай (самый “слабый” разрез).

---

## 8) Вершинная связность κ (node-splitting) — подробный разбор

### 8.1. Проблема
Нужно “удалять вершины”, а поток удаляет рёбра.

### 8.2. Решение: разбиение вершины
Каждую вершину v заменяем на vin(v) и vout(v). Добавляем ребро:
- vin(v)→vout(v) с capacity=1 (для обычных вершин)

Для выбранных s и t ставим capacity=INF, чтобы не «удалить» источники.

### 8.3. Как вставляем исходные рёбра
Каждое ребро u—v превращаем в дуги:
- vout(u)→vin(v) (INF)
- vout(v)→vin(u) (INF)

Теперь любой разрез по vin→vout соответствует удалению вершины, а min-cut даёт κ.

---

## 9) Формирование результата в sc-памяти

После вычислений агент:
1) создаёт элементы структуры результата,  
2) записывает κ и λ (числовые значения),  
3) добавляет найденные точки сочленения и мосты в соответствующие множества,  
4) прикрепляет результат к action.

Это важно: результат хранится в KB и может быть использован дальше (например, для визуализации).

---

## 10) Unit-тесты: почему это главный аргумент

Тесты доказывают корректность автоматически:
- создают графовую топологию,
- запускают action,
- ждут агента,
- читают результат и сравнивают с эталоном.

Если `ctest` показывает `PASSED`, это означает, что:
- агент реально запускается,
- вычисления выполняются,
- результаты записаны в память корректно.

---

## 11) Разбор тестов (подробно)

### 11.1. Cycle
Ожидаемо: κ=2, λ=2, мостов 0, точек 0.  
Причина: цикл устойчив к отказу одного ребра/вершины.

### 11.2. Chain
Ожидаемо: κ=1, λ=1, мосты все, точки — внутренние.  
Причина: любая потеря ребра/узла разрывает цепь.

### 11.3. Star
Ожидаемо: центр — точка сочленения; все рёбра — мосты; κ=1, λ=1.  
Причина: центр — единственный “коммутатор” между листьями.

### 11.4. Bowtie
Ожидаемо: общая вершина — точка; мостов нет; κ=1; λ=2.  
Причина: для отделения левого/правого треугольника нужно удалить два ребра, ведущих из общей вершины в соответствующий треугольник.

---

## 12) Команды: полный чек-лист (без личных путей)

Во всех командах используйте обозначение корня проекта: `<PROJECT_ROOT>`.

### 12.1. KB
```bash
cd <PROJECT_ROOT>
./scripts/start.sh build_kb
```

### 12.2. Модуль
```bash
cd <PROJECT_ROOT>
cmake --preset release-conan
cmake --build --preset release
```

### 12.3. Тесты (3 команды)
```bash
cd <PROJECT_ROOT>
cmake --preset release-with-tests-conan
cmake --build build/Release
ctest --test-dir build/Release --output-on-failure -V
```

### 12.4. Тесты (одной строкой — для демонстрации)
```bash
cd <PROJECT_ROOT> && cmake --preset release-with-tests-conan && cmake --build build/Release && ctest --test-dir build/Release --output-on-failure -V
```

### 12.5. Web (если нужно)
```bash
cd <PROJECT_ROOT>
./scripts/start.sh web
```
Открыть: `http://localhost:8000`.

---

## 13) Интерпретация логов агента

Сообщения вида «проверка условия инициации неуспешна» возможны, если агент увидел действие не своего класса. Это не ошибка. Важно, чтобы на правильном action было «finished performing action successfully».

---

## 14) Типовые проблемы и решения

### 14.1. gtest не найден при сборке модуля
Причина: тестовый файл попал в сборку библиотеки. Решение: исключить `test/` из источников в `CMakeLists.txt`.

### 14.2. В sc-web не отображаются компоненты
Причина: не собран фронтенд. Решение: `npm install` + `npm run build` + симлинк `static`.

---

## 15) Подготовка к защите: короткие ответы

**Почему граф неориентированный?** — физическая связь двусторонняя; агент добавляет смежность в обе стороны.  
**Что такое κ и λ?** — κ: минимум устройств для разрыва сети; λ: минимум линий связи.  
**Как доказали корректность?** — 4 автоматических теста + успешный `ctest`.

---

## 16) Приложения

### 16.1. Структура (обобщённо)
- `knowledge-base/` — SCs и предметная область  
- `problem-solver/network_resilience_module/` — агент и тесты  
- `interface/sc-web/` — web  
- `scripts/` — запуск и сборка

### 16.2. Полезная «однострочная» команда для демонстрации тестов
```bash
cd <PROJECT_ROOT> && cmake --preset release-with-tests-conan && cmake --build build/Release && ctest --test-dir build/Release --output-on-failure -V
```

---

**Конец документа.**
